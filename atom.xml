<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Sample & Hold]]></title>
  <link href="http://sample-hold.github.io/atom.xml" rel="self"/>
  <link href="http://sample-hold.github.io/"/>
  <updated>2015-11-25T00:47:11+01:00</updated>
  <id>http://sample-hold.github.io/</id>
  <author>
    <name><![CDATA[Fred Ghilini]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Make Fun of Your Launchpad With LaunchPlay VST Plugin]]></title>
    <link href="http://sample-hold.github.io/2011/12/19/make-fun-of-your-launchpad-with-launchplay-vst-plugin/"/>
    <updated>2011-12-19T05:00:26+01:00</updated>
    <id>http://sample-hold.github.io/2011/12/19/make-fun-of-your-launchpad-with-launchplay-vst-plugin</id>
    <content type="html"><![CDATA[<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/launchplay-image.png"> I bought a Launchpad controller from Novation a few years ago, and although it&rsquo;s a great midi interface offering a perfect native remote for Ableton Live sequencer, I couldn&rsquo;t help thinking that this amazing tool could certainly be used in other unexpected ways, thus controlling alternate gears or software. So on the same time, I was both enjoying my Launchpad and drooling to what would have offered at more experimental controller such as <a href="http://monome.org/devices">monome device</a>&hellip;</p>

<p>Luckily, Novation made a programming guide available for the Lauchpad, as well as Ableton proposed an extended version of Live integrating Max/MSP (that is called &ldquo;Max for Live&rdquo;) that would help me satisfy my nerd-est desires. So I started to draft a layout for simple jamming. But I wanted more : my tool would work on any sequencer, with both Mac and Windows platforms, all of this requiring no additional license.</p>

<p>Evidently, I got a bunch of new ideas when I started writing for sample-hold.com: I was now dreaming about a VST plugin that would act as a MIDI effect, allowing pure jams with a touch of randomness. I think I&rsquo;ve come up with a preliminary version called &ldquo;LaunchPlay VST&rdquo;. Let&rsquo;s look at it and explain how to use this strange plugin&hellip; <!-- more --></p>

<h3>Disclaimer</h3>

<p>First of all, the jamming idea of LaunchPlay VST is not really new and I would like to thanks Batuhan Bozkurt for his genius work on Otomata (<a href="http://www.earslap.com/">his website</a>), an online generative music instrument, because this is from where my work starts. While Batuhan made a mobile application of his work, on my side I have always considered that this would not suit the needs of some musicians and producers that were buying a lot a gears or synthetizers, and just wanted&hellip; to use them, leaving their cellphone in their pocket. That could be the benefit of a MIDI plugin.</p>

<p>So, LaunchPlay is a<strong> VST plugin for Mac and Windows</strong>, containing three sub plugins :</p>

<ul>
<li><p>LaunchPlay VSTi: the main sequencer that you will insert into a new &ldquo;instrument&rdquo; track,</p></li>
<li><p>LaunchPlayVirtualCable VST: a great companion that will help you overcome the MIDI routing issue we describe below,</p></li>
<li><p>LaunchPlay MidiFilter VST: another companion that can help you achieve the MIDI routing.</p></li>
</ul>


<h3>LaunchPlay layout</h3>

<p>Here is the very simple layout available for use in LaunchPlay:</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/launchplay-layout.png"></p>

<p>You may notice that the rightmost buttons of the Launchpad have been turned into a MIDI channel selector : this will allow us to send generative music to up to eight gears (virtual instruments or real synthetizers), bringing a nice multi-timbral feature to our generative music experience!</p>

<p>The grid is where you play notes in a quite similar way than Otomata (well, not exactly). And we can reuse the top buttons for some new features not included in the genuine LaunchPad:</p>

<ul>
<li><p>up, down, left, right: this is where you change the direction before creating a new &ldquo;worker&rdquo; on the grid,</p></li>
<li><p>delete one: this is a switch button. When it&rsquo;s red, you&rsquo;re on the &ldquo;remove&rdquo; mode and you should be able to individually remove workers,</p></li>
<li><p>delete all: this is an instant button, used to remove all workers on the current grid,</p></li>
<li><p>ticks: they are pretty useless visual markers indicating that your sequencer is running.</p></li>
</ul>


<p>Before I explain the required MIDI routing, let&rsquo;s watch a demo video:</p>

<iframe width="560" height="420" src="http://www.youtube.com/embed/JWVFdrywEqc?color=white&theme=light"></iframe>


<h3>MIDI routing</h3>

<p>For proper work, LaunchPlay needs you to setup this MIDI routing in your VST Host:</p>

<ul>
<li><p>LaunchPlay VSTi must receive notes from LaunchPad</p></li>
<li><p>It will send MIDI events from channel 1 to channel 9:</p>

<ul>
<li><p>channel 1 is dedicated for feedback events. They must be routed to the LaunchPad, using either my MidiFilter or VirtualCable plugins.</p></li>
<li><p>channels 2-9 are receiving notes coming from the eight different layers of the LaunchPlay Sequencer</p></li>
</ul>
</li>
</ul>


<p><img class="centered" src="http://sample-hold.github.io/images/blog/routing.png"></p>

<p>You can use:</p>

<ul>
<li><p><strong>LaunchPlayMidiFilter</strong>, which aims to filter received MIDI events in order to &ldquo;pass-thru&rdquo; events that correspond to a given channel,</p></li>
<li><p><strong>LaunchPlayVirtualCable</strong>, which allow to bind channels from the LaunchPlaySequencer to any MIDI track of your VST Host (very handy, for instance, in Ableton Live, which doesn&rsquo;t allow to routing many MIDI channels between VST plugins)</p></li>
<li><p>or your VST host native routing features, if any.</p></li>
</ul>


<p>I can show you my typical routing done in Live:</p>

<iframe width="560" height="420" src="http://www.youtube.com/embed/lJOVjKdoO9E?color=white&theme=light"></iframe>


<h3>Grab the source code &amp; contribute</h3>

<p>You can as usual grab everything for free on the <a href="https://github.com/Sample-Hold/LaunchPlayMIDIEffect">projects' GitHub page</a>.</p>

<p>Please note that everything is licensed under a <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>, so don&rsquo;t make any commercial use of this, share it, talk about it, in the name of fun, thanks!</p>

<p>Final thoughts</p>

<p>To wrap up this article, Launch Play was as fun to build as it&rsquo;s probably fun to use! Of course, I had a lot of issues to overcome. For instance, VST plugins are not really tailored to behave a MIDI effect, and I had to find out a few tricks to be able to correctly route MIDI messages  between the LaunchPlay sequencer and instruments. I discovered that there is no official API for designing MIDI effect, despite that Steinberg provides the <a href="http://www.steinberg.net/en/company/developer.html">VST Module Architecture SDK</a>, which is unfortunately not used by most of the sequencers.</p>

<p><strong>Edit 28/12/11</strong>: some users have reported that the &ldquo;Virtual Cable&rdquo; mode can be very laggy on some configurations. I am working on an solution using another library for sending messages between channels. In the meantime, I suggest using pure MDI routing: for this, unfortunately, you must switch the last VST parameter from &ldquo;Virtual&rdquo; to &ldquo;MIDI&rdquo; and set up your own routing.</p>

<p><strong>Edit 17/01/12</strong>: for those who asked, yeees, by the way, the first video I recorded is back online! One can enjoy  my sweety pony melody again:</p>

<iframe width="560" height="420" src="http://www.youtube.com/embed/pdshwDY19s4?color=white&theme=light"></iframe>


<p>I&rsquo;m thinking about some new tutorials to write on sample-hold.com. I don&rsquo;t know yet, we could discuss about writing a new VST plugin from scratch, or we could study some programming tricks based on the LaunchPlay sources. If you have any precise idea on what you would like to see on this website, please leave a comment!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a FFT Analyzer Part v: Final Thoughts, Sources for XCode 4.2 & Feedback]]></title>
    <link href="http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-v-final-thoughts-sources-for-xcode-4-2-feedback/"/>
    <updated>2011-11-23T16:34:55+01:00</updated>
    <id>http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-v-final-thoughts-sources-for-xcode-4-2-feedback</id>
    <content type="html"><![CDATA[<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/au.gif"> This part wraps up our tutorial on building an audio effect as Audio Unit for OS X Lion. Though it is not the craziest plug-in you&rsquo;ll ever built, it made us learn some basis about DSP programming, as well it introduced the XCode environment for developing Audio Units. Of course, there are numerous improvements we could do on this project. In this article, I&rsquo;ll make some remarks about my work and  also a few issues I met during development. Last but not least, we recall the GitHub repository URL for you to grab the code and make our own version.</p>

<!-- more -->


<h3>Remarks</h3>

<p>After thinking twice about it, here are the things I finally dislike :</p>

<ul>
<li><p><strong>Mixing C, C++ and Objective-C in a (small) project is a bad idea</strong>: it definitely make your developer duties harder. I would personally prefer to stick to C++ for all tasks. Using Cocoa UI was a good way to challenge the native SDK of Mac, but I may prefer using another SDK that avoid sprinkling our code, and thus, knowledge.</p></li>
<li><p><strong>Not all features of Cocoa are supported by AU/VST hosts</strong>: for instance, I couldn&rsquo;t resize my spectrum analyzer view in Ableton Live and Garage Band, and I couldn&rsquo;t display the NSMenu as context menu when right-clicking on the Cocoa window.</p></li>
<li><p><strong>NSBezierPath is slow</strong>: You might have noticed how slow it is when choosing 16384 as your FFT block size. We could  probably have had better results with a Quartz or OpenGL rendering. To be perfectly honest, at first, I tried to elaborate an OpenGL version of this tutorial, but I ran into an graphical bug with Ableton Live: it seemed that my plug-in wasn&rsquo;t properly releasing the OpenGL context, thus corrupting the entire Live UI. I could not get out of this, so I decided to revert to a more &ldquo;portable&rdquo; solution for drawing the spectrum graph (though it&rsquo;s exaggerated  writing that Cocoa is &ldquo;portable&rdquo; ;)).</p></li>
<li><p><strong>The overall result isn&rsquo;t as precise as we wanted</strong>: our graph is not big enough to give you valuable informations about dB amplitudes (especially if the host doesn&rsquo;t allow our plug-in to be resized!). We should have added some precious features like zoom, prevision, hold peaks, etc. (this is out of scope of this tutorial). And there might be more precise methods rather than simply adding a constant dB correction into our <em>SimpleSpectrumProcessor</em> class.</p></li>
<li><p><strong>We should have proposed a solution for developing both VST au AU versions of our Spectrum Analyzer</strong>: but, as a drawback, it would make our tutorial much more difficult. Anyway, I&rsquo;ll probably publish another tutorial for this in the future.</p></li>
</ul>


<h3>Give feedback and share this code</h3>

<p>Feedback is welcome! You may leave a comment at the bottom of this article.</p>

<p>In the meantime, you can contribute to this tutorial by registering yourself on GitHub and cloning my repository : <a href="https://github.com/Sample-Hold/SimpleSpectrumAnalyzer">https://github.com/Sample-Hold/SimpleSpectrumAnalyzer</a></p>

<h3>Final words</h3>

<p>I spent a couple of minutes hacking my code in order to show you in a video how I had corrupted the Ableton Live UI when I was using a NSOpenGLView instead of a NSView. Unfortunately, I&rsquo;m completely unable to reproduce this bug! That&rsquo;ll teach me not to version every compiled binary as nightly builds ;)</p>

<p>Before I throw out this hack, I can show you what it is like this OpenGL version of the Simple Spectrum Analyzer:</p>

<iframe width="560" height="420" src="http://www.youtube.com/embed/8nnl2BFCZQ8?color=white&theme=light"></iframe>


<p>As a conclusion, we can see that the OpenGL alternative still renders slowly with an FFT size of 16384 samples. So there must be a lot of performance tweaks to perform elsewhere. For anybody interested, the alternate code has been pushed to GitHub.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a FFT Analyzer Part IV: Debugging Our Audio Unit With AU Lab]]></title>
    <link href="http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-iv-debugging-our-audio-unit-with-au-lab/"/>
    <updated>2011-11-23T16:33:15+01:00</updated>
    <id>http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-iv-debugging-our-audio-unit-with-au-lab</id>
    <content type="html"><![CDATA[<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/aulab2.png"> Debugging an Audio Unit is not as straightforward as debugging a Cocoa application, because your freshly coded component doesn&rsquo;t show up until you insert it in a bus of your favorite DAW.</p>

<p>In this article, we review some methods for automating your debugging sessions using XCode 4. Concerning the DAW, our preference goes for a free host available in the CoreAudio SDK: AU Lab. In only a few steps, you will be able to setup some breakpoints and look into all potential devilish bugs as if you were debugging a simple Cocoa application.</p>

<!-- more -->


<h3>Prerequisites</h3>

<p>We assume that you&rsquo;ve downloaded <a href="http://github.com/fredguile/SimpleSpectrumAnalyzer">the sources of this tutorial on GitHub</a>, and that you have successfully built your component with the default debug configuration.</p>

<h3>Manage schemes</h3>

<p>Xcode 4 provides a classic workflow for testing and packaging your component:</p>

<ol>
<li><p>Build your component</p></li>
<li><p>Run it using debug configuration</p></li>
<li><p>Test it using debug configuration</p></li>
<li><p>Profile it using release configuration</p></li>
<li><p>Analyze your code for possible tweaks</p></li>
<li><p>Archive a delivery for distributing</p></li>
</ol>


<p>This basically suits our needs. The only thing we have to do is launching &ldquo;AU Lab&rdquo; on step 2:</p>

<ul>
<li><p>Click on your target &ldquo;SpectrumAU&rdquo; in the top left area of XCode</p></li>
<li><p>Choose &ldquo;Edit scheme&hellip;&rdquo;</p></li>
<li><p>Select step &ldquo;Run - Debug&rdquo;</p></li>
<li><p>In the &ldquo;Executable&rdquo; field, choose &ldquo;Other&hellip;&rdquo; and browse you Mac in order to find &ldquo;/Developer/Applications/Audio/AU Lab&rdquo;</p></li>
<li><p>Save scheme</p></li>
</ul>


<p><img class="centered" src="http://sample-hold.github.io/images/blog/xcode-edit-scheme.png?w=300"></p>

<p>Now, AU Lab will automatically launch each time you hit &ldquo;Run&rdquo;.</p>

<p>Still, your Audio Unit doesn&rsquo;t show up, because we haven&rsquo;t copied the file <em>SimpleSpectrumAU.component</em> into your audio plugins folder. Since we don&rsquo;t want to do it each time we compile a new version, we ought to tweak a bit our build settings to automate this.</p>

<h3>Tweaking build settings</h3>

<p>There are a couple of build settings that may help us automating each deployment.</p>

<p>To understand how they work, let&rsquo;s make a few changes as a first try:</p>

<ul>
<li><p>deployment > Deployment Location: choose &ldquo;Yes&rdquo;</p></li>
<li><p>deployment > Deployment Postprocessing: choose &ldquo;Yes&rdquo;</p></li>
<li><p>deployment > Installation Build Products Location: type &ldquo;/&rdquo;</p></li>
<li><p>deployment > Installation Directory: write &ldquo;$(USER_LIBRARY_DIR)/Audio/Plug-Ins/Components/&rdquo;</p></li>
</ul>


<p>As a result, your audio unit is copied into your audio plugins folder each time you build! So, in one-pass, we successively build our audio unit, deploy it to the proper folder then run AU Lab to start a debugging session.</p>

<p>But I still get an annoying issue on my side (perhaps you won&rsquo;t get it) : <strong>breakpoints don&rsquo;t break.</strong> I suspect Xcode not doing the things we want. When I look into the &ldquo;Debug&rdquo; folder, the compiled component has turned into an alias, pointing to a binary now located in $(USER_LIBRARY_DIR)/Audio/Plug-Ins/Components/.</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/xcode-created-an-alias.png"></p>

<p>Actually, I don&rsquo;t think the build settings we mentioned above are a viable solution for the &ldquo;debug&rdquo; configuration. However, we could keep them for the next stages of our workflow, so I suggest changing the build setting in that way:</p>

<ul>
<li><p>deployment > Deployment Location:</p>

<ul>
<li><p>choose &ldquo;No&rdquo; for debug</p></li>
<li><p>choose &ldquo;Yes&rdquo; for release</p></li>
</ul>
</li>
<li><p>deployment > Deployment Postprocessing:</p>

<ul>
<li><p>choose &ldquo;No&rdquo; for debug</p></li>
<li><p>choose &ldquo;Yes&rdquo; for release</p></li>
</ul>
</li>
<li><p>deployment > Installation Build Products Location:</p>

<ul>
<li><p>write &ldquo;/tmp/$(PROJECT_NAME).dst&rdquo; for debug</p></li>
<li><p>write &ldquo;/&rdquo; for release</p></li>
</ul>
</li>
<li><p>deployment > Installation Directory: write &ldquo;$(USER_LIBRARY_DIR)/Audio/Plug-Ins/Components/&rdquo;</p></li>
</ul>


<p>There is another trick we could try in order to automate our deployment in debug mode:</p>

<ul>
<li><p>Open the &ldquo;Build phases&rdquo;</p></li>
<li><p>Add a &ldquo;Copy files&rdquo; phase as the last build phase</p></li>
<li><p>Specify an &ldquo;absolute path&rdquo; as destination: $(USER_LIBRARY_DIR)/Audio/Plug-Ins/Components/</p></li>
<li><p>Add the file &ldquo;SimpleSpectrumAnalyzer.component&rdquo; to the list</p></li>
</ul>


<p>Now everything should be okay and our breakpoints will correctly <strong>break</strong>. The only drawback of this method is that you&rsquo;ll have to cancel this build phase before you move into the next stages of you workflow. You must delete when I build your &ldquo;release&rdquo; configuration, else XCode will alert you of a possible loop when executing your deployment workflow.</p>

<h3>Still&hellip; no sound ?</h3>

<p>First off, don&rsquo;t forget to start the AU Lab engine if you want your Audio Unit to process any sample. You can do this by clicking on the label &ldquo;Audio engine stopped&rdquo; on the lowest part of AU Lab&rsquo;s mixer.</p>

<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/smartelectronix.png"> Next, I recommend downloading the MDA AU plug-ins from <a href="http://mda.smartelectronix.com/effects.htm">Smartelectronix&rsquo;s website</a> in order to test our Spectrum Analyzer with a simple sinusoid as input signal. After you have installed it, you should be able to use the &ldquo;TestTone&rdquo; plug-in and generate a pure sine signal to test our spectrum analyzer:</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/debugging-simplespectrum-analyzer-with-1024-samples.png" title="Blocksize is 1024 samples" ></p>

<p>By the way, we shall notice how inaccurate is our analyzer when testing a low-frequency sine-wave with 1024 samples as FFT Size. We can correct that by raising our FFT size : right-click on the graph and choose &ldquo;2048&rdquo; as block size.</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/debugging-simplespectrum-analyzer-with-2048-samples.png" title="With 2048 samples" ></p>

<p>And I&rsquo;m still looking for a way to modulate the phase of this sine wave, in order to test &ldquo;frequency leakage&rdquo; and measure efficiency of our different window functions. You you have a trick for this with MDA AU or any other plug-in, please don&rsquo;t hesitate to leave me a comment !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a FFT Analyzer Part III: Building UI With Cocoa and Objective-C]]></title>
    <link href="http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-iii-building-ui-with-cocoa-and-objective-c/"/>
    <updated>2011-11-23T16:32:10+01:00</updated>
    <id>http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-iii-building-ui-with-cocoa-and-objective-c</id>
    <content type="html"><![CDATA[<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/images1.jpeg?w=150"> In this part of the tutorial, we are going to design a Cocoa UI in order to draw the spectrum graph computed by our unit, in which we&rsquo;ll create widgets so as to configure the FFT analysis.</p>

<p>Why using Cocoa? Well, for two reasons: I didn&rsquo;t want to introduce a too complex API in this tutorial (such as OpenGL), and I would like to show you how to mix C++ and Objective-C in the same XCode project. Don&rsquo;t worry, it doesn&rsquo;t bother if you&rsquo;re not experienced with Objective-C: we&rsquo;ll make a straightforward use of it and we&rsquo;ll clearly explain all the interactions between our GUI classes and our C++ code.</p>

<!-- more -->


<h3>One build target more</h3>

<p>First off, we ought to organize a bit our XCode project before we start coding our Cocoa UI. I may suggest you to create a new folder into &ldquo;Sources&rdquo; that will contain all your Objective-C code. Let&rsquo;s call it &ldquo;SpectrumCocoaView&rdquo;.</p>

<p>We need to add a new build target to our project:</p>

<ol>
<li><p>Choose the template &ldquo;Mac OS X > Framework &amp; Library > Bundle&rdquo; and call you target &ldquo;SpectrumCocoaView&rdquo;. Please note that we don&rsquo;t use the &ldquo;Automatic Reference Counting&rdquo; feature in this tutorial, so you may uncheck it. And yes, this time, you must link your target to the Cocoa framework.</p></li>
<li><p>Edit your new target&rsquo;s build settings and add this to the &ldquo;Other Linker flags&rdquo;: <em>-framework Foundation -framework AppKit </em></p></li>
<li><p>There&rsquo;s not much to say about build phases: we classically include the required headers, then our Objective-C sources, however we just must not forget to add a XIB file which describes our GUI. I&rsquo;ll explain this very soon.</p></li>
</ol>


<p>You have to make a &ldquo;build relationship&rdquo; between you two targets :</p>

<ol>
<li><p>Open the build phases for your C++ target called &ldquo;SimpleSpectrumAnalyzer&rdquo;.</p></li>
<li><p>Add a build phase of type &ldquo;Target dependencies&rdquo; <strong>positioned as your first operation</strong>.</p></li>
<li><p>Then add the product &ldquo;SpectrumCocoaView&rdquo; as a dependency.</p></li>
</ol>


<p>Perhaps you don&rsquo;t want to put your hands into problems for now, so you may prefer <a href="http://github.com/fredguile/SimpleSpectrumAnalyzer">grabbing our existing XCode project</a> before you continue your reading.</p>

<h3>Design your interface</h3>

<p>That&rsquo;s where you create a new XIB file (preferably in your &ldquo;Resources&rdquo; folder) in order to design your GUI. At this step, we just draw our GUI components, and keep all the logic inside Objective-C classes we&rsquo;ll create afterwards. It&rsquo;s a good occasion to separate concerns between components: our Spectrum Analyzer GUI will divide the work between two main classes.</p>

<p>Here are the components we need to add to this document:</p>

<ul>
<li><p>The root view, called &ldquo;SpectrumAnalyzerView&rdquo;: a <strong>Custom View</strong> responsible for all exchanges between the Audio Unit and the GUI, like sending/receiving parameters, or receiving new audio data to draw.</p></li>
<li><p>The subview, called &ldquo;SimpleSpectrumGraphView&rdquo;: a <strong>Custom View</strong> responsible for drawing the GUI using basic Cocoa objects such as Bezier curve, text labels, etc.</p></li>
<li><p>We add a child element to the subview: a <strong>TextField</strong> widget, that we&rsquo;ll use to give more precise informations about frequencies and magnitudes.</p></li>
</ul>


<p>Finally, We create a <strong>NSMenu </strong>widget in order to let users modify the Audio Unit parameters. It will pops up when you right-click anywhere in the SpectrumAnalyzerView.</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/capture-d_c3a9cran-2011-11-29-c3a0-18-14-07.png?w=300"></p>

<h3>Create GUI classes</h3>

<p>For each custom view that we have added above, we need to create a class owning the programming logic. Objective-C is quite similar than C++: you first define your classes into header files, then implement them in source files. There are two things you should know before creating them:</p>

<ul>
<li><p>Objective-C can contain either C or C++ code. It depends of the file&rsquo;s extension you choose when you create your implementation : .m stands for C, .mm for C++. To keep this tutorial simple, and because we&rsquo;ll include C++ headers in our Objective-C classes, I strongly suggest<strong> renaming all your .m extensions to .mm extensions</strong>.</p></li>
<li><p>There is no namespace in Objective-C, so Apple recommends to name all you classes using very specific names.</p></li>
</ul>


<p>Before you go, don&rsquo;t forget to choose the &ldquo;SpectrumCocoaView&rdquo; target each time you create a new Objective-C class. So we create these ones:</p>

<ul>
<li><p><strong>SimpleSpectrum_GraphView</strong></p></li>
<li><p><strong>SimpleSpectrum_UIView</strong></p></li>
<li><p>and a very important one, <strong>SimpleSpectrum_ViewFactory</strong></p></li>
</ul>


<p>What is it for? This latter class is responsible for binding your GUI with you Audio Unit, hence it must implement the <strong>AUCocoaUIBase</strong> protocol. What is a protocol? It&rsquo;s more or less like an interface in Java: by adding it to your class, you agree to implement all the methods defined inside. So in our case, it&rsquo;s necessary to implement this method:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-(</span><span class="n">NSView</span> <span class="o">*</span><span class="p">)</span><span class="nf">uiViewForAudioUnit:</span><span class="p">(</span><span class="n">AudioUnit</span><span class="p">)</span><span class="nv">inAudioUnit</span> <span class="nf">withSize:</span><span class="p">(</span><span class="n">NSSize</span><span class="p">)</span><span class="nv">inPreferredSize</span> <span class="p">{</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="bp">NSBundle</span> <span class="nl">loadNibNamed</span><span class="p">:</span><span class="s">@&quot;SpectrumView&quot;</span> <span class="nl">owner</span><span class="p">:</span><span class="nb">self</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Unable to load nib from view&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">uiFreshlyLoadedView</span> <span class="nl">setAU</span><span class="p">:</span><span class="n">inAudioUnit</span><span class="p">];</span>
</span><span class='line'><span class="n">NSView</span> <span class="o">*</span><span class="n">returnView</span> <span class="o">=</span> <span class="n">uiFreshlyLoadedView</span><span class="p">;</span>
</span><span class='line'><span class="n">uiFreshlyLoadedView</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span> <span class="c1">// zero out pointer.  This is a view factory.  Once a view&#39;s been created</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// and handed off, the factory keeps no record of it.</span>
</span><span class='line'><span class="k">return</span> <span class="p">[</span><span class="n">returnView</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Bind UI widgets to IBActions</h3>

<p>This is the fun part of the Cocoa Framework. All you have to do is:</p>

<ol>
<li><p>in your Objective-C code:</p></li>
<li><p>declare all your subviews and widgets as member variables of you custom class, using pointers to their base class</p></li>
<li><p>put the magic qualifier <strong>IBOutlet</strong> on each variable</p></li>
<li><p>create &ldquo;action methods&rdquo; that return the <strong>IBAction</strong> type and take an unique parameter of type <strong>id</strong></p></li>
<li><p>in the XIB document:</p></li>
<li><p>select each view (or widget) for which you have developed a custom class</p></li>
<li><p>define this custom class in the &ldquo;Class&rdquo; attribute (on the right pane of Xcode)</p></li>
<li><p>bind <strong>Outlets </strong>together, that is to say, bind views with their subview and their widgets</p></li>
<li><p>bind <strong>Received Actions </strong>with the methods you&rsquo;ve previously created</p></li>
</ol>


<p><img class="centered" src="http://sample-hold.github.io/images/blog/capture-d_c3a9cran-2011-11-29-c3a0-20-54-13.png?w=179"></p>

<p>So far, we have designed a basic Cocoa UI and we have bound the most important widgets to actions developed in Objective-C classes. We have had an overall sight of how our Spectrum Analyzer basically interacts with the Cocoa UI.</p>

<p>We&rsquo;ll soon study how to draw a beautiful spectrum analyzer, but in the meantime, we need to talk about the data we need to manage on both sides in order to transmit the FFT analysis to the UI.</p>

<h3>Create Audio Unit&rsquo;s parameters and properties</h3>

<p>Your GUI will communicate with your Audio Unit using two types of data:</p>

<ul>
<li><p><strong>parameters</strong>: they hold user settings. They are called by the Audio Unit during audio processing and they are called by the GUI classes when the user modify them through UI widgets,</p></li>
<li><p><strong>properties</strong>: they hold any kind of data exchanged between the Audio Unit, the Host and the GUI. They can be defined in the CoreAudio SDK, as well in your code as &ldquo;custom properties&rdquo;.</p></li>
</ul>


<p>For our Spectrum analyzer, we define these three parameters:</p>

<ul>
<li><p><strong>kSpectrumParam_BlockSize</strong>: the FFT block size, from 1024 to 16384 samples. By raising this parameters, we raise the FFT precision, but in the other hand we get slower computing/drawing times,</p></li>
<li><p><strong><strong>kSpectrumParam_SelectC</strong>hannel</strong>: a simple parameter to restrict FFT analysis on left or right channel (if our audio unit is inserted into a stereo bus),</p></li>
<li><p><strong>kSpectrumParam_Window</strong>: the window function we choose to compute our samples before we do FFT analysis.</p></li>
</ul>


<p>And we need those two custom properties:</p>

<ul>
<li><p><strong>kAudioUnitProperty_SpectrumGraphInfo</strong>: a simple structure that hold the infos our GUI needs to know before it can draw a spectrum graph,</p></li>
<li><p><strong>kAudioUnitProperty_SpectrumGraphData</strong>: an array of floating-point numbers to pass the computed magnitudes to the GUI.</p></li>
</ul>


<p>Building those parameters and properties on the Audio Unit side would require to add another endless part to this tutorial. Fortunately, there are many articles available on the net and I suggest reading <a href="http://developer.apple.com/library/mac/#documentation/MusicAudio/Conceptual/AudioUnitProgrammingGuide/Tutorial-BuildingASimpleEffectUnitWithAGenericView/Tutorial-BuildingASimpleEffectUnitWithAGenericView.html">the official Apple tutorial</a> if you want to get more details in creating them in your C++ code .</p>

<p>Still, we must comment some lines of code from the C++ class &ldquo;SimpleSpectrum&rdquo;:</p>

<ul>
<li>Parameters must be declared as soon as your Audio Unit initializes:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">SimpleSpectrum</span><span class="o">::</span><span class="n">SimpleSpectrum</span><span class="p">(</span><span class="n">AudioUnit</span> <span class="n">component</span><span class="p">)</span> <span class="o">:</span> <span class="n">AUEffectBase</span><span class="p">(</span><span class="n">component</span><span class="p">),</span> <span class="n">mCAMutex</span><span class="p">(</span><span class="s">&quot;mutex&quot;</span><span class="p">){</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">SetParameter</span><span class="p">(</span><span class="n">kSpectrumParam_BlockSize</span><span class="p">,</span> <span class="n">kBlockSize_Default</span><span class="p">);</span>
</span><span class='line'><span class="n">SetParameter</span><span class="p">(</span><span class="n">kSpectrumParam_SelectChannel</span><span class="p">,</span> <span class="n">kSelectChannel_Default</span><span class="p">);</span>
</span><span class='line'><span class="n">SetParameter</span><span class="p">(</span><span class="n">kSpectrumParam_Window</span><span class="p">,</span> <span class="n">kWindow_Default</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>It&rsquo;s best to declare all parameters and properties in a separate C++ header: <em>SimpleSpectrumSharedData.h</em> in our case. That way, we could use C++ for our Audio Unit and restrict our GUI code to pure Objective-C and C</p></li>
<li><p>Basically, to use a parameter defined both in the Audio Unit and the GUI, we have to call:</p>

<ul>
<li><p>from the Audio Unit side: <em>GetParameter(kSpectrumParam_BlockSize)</em></p></li>
<li><p>from the Cocoa UI side: <em>AudioUnitGetParameter(mAU, kSpectrumParam_BlockSize, kAudioUnitScope_Global, 0, &amp;inValue)</em></p></li>
</ul>
</li>
<li><p> In this tutorial, we assume that the GUI has previously allocated sufficient memory <strong>before</strong> it requests any property content. Hence it&rsquo;s also responsible for freeing this memory when it&rsquo;s released. That&rsquo;s why the code that transmit our custom properties looks like this, without allocating anything:</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">case</span> <span class="nl">kAudioUnitProperty_SpectrumGraphData</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">Float32</span><span class="o">*</span> <span class="n">mData</span> <span class="o">=</span> <span class="p">(</span><span class="n">Float32</span><span class="o">*</span><span class="p">)</span> <span class="n">outData</span><span class="p">;</span>
</span><span class='line'>   <span class="k">if</span><span class="p">(</span><span class="n">mInfos</span><span class="p">.</span><span class="n">mNumBins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">mCAMutex</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
</span><span class='line'>      <span class="n">memcpy</span><span class="p">(</span><span class="n">mData</span><span class="p">,</span> <span class="n">mComputedMagnitudes</span><span class="p">(),</span> <span class="n">mInfos</span><span class="p">.</span><span class="n">mNumBins</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Float32</span><span class="p">));</span>
</span><span class='line'>      <span class="n">mCAMutex</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>On the other side, in the class SimpleSpectrum_UIView class:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">SpectrumGraphInfo</span> <span class="n">graphInfo</span><span class="p">;</span>
</span><span class='line'><span class="n">graphInfo</span><span class="p">.</span><span class="n">mNumBins</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">UInt32</span> <span class="n">sizeOfResult</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">graphInfo</span><span class="p">);</span>
</span><span class='line'><span class="n">ComponentResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">AudioUnitGetProperty</span><span class="p">(</span><span class="n">mAU</span><span class="p">,</span>
</span><span class='line'>                                                  <span class="n">kAudioUnitProperty_SpectrumGraphInfo</span><span class="p">,</span>
</span><span class='line'>                                                  <span class="n">kAudioUnitScope_Global</span><span class="p">,</span>
</span><span class='line'>                                                  <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                                                  <span class="o">&amp;</span><span class="n">graphInfo</span><span class="p">,</span>
</span><span class='line'>                                                  <span class="o">&amp;</span><span class="n">sizeOfResult</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">noErr</span> <span class="o">&amp;&amp;</span> <span class="n">graphInfo</span><span class="p">.</span><span class="n">mNumBins</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CAAutoFree</span> <span class="n">graphData</span><span class="p">;</span>
</span><span class='line'>        <span class="n">graphData</span><span class="p">.</span><span class="n">allocBytes</span><span class="p">(</span><span class="n">sizeOfResult</span> <span class="o">=</span> <span class="n">graphInfo</span><span class="p">.</span><span class="n">mNumBins</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Float32</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">result</span> <span class="o">=</span> <span class="n">AudioUnitGetProperty</span><span class="p">(</span><span class="n">mAU</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">kAudioUnitProperty_SpectrumGraphData</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">kAudioUnitScope_Global</span><span class="p">,</span>
</span><span class='line'>                                      <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                                      <span class="n">graphData</span><span class="p">(),</span>
</span><span class='line'>                                      <span class="o">&amp;</span><span class="n">sizeOfResult</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">graphView</span> <span class="nl">plotData</span><span class="p">:</span> <span class="n">graphData</span> <span class="nl">givenInfos</span><span class="p">:</span> <span class="n">graphInfo</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>The most of you, readers, will have noticed that we protect access to the computed magnitudes array with a mutex, provided by the class <strong>CAMutex</strong> (found in the &ldquo;PublicUtility&rdquo; folder). This is because the GUI code and the Audio Unit code both run in separate threads. The former may ask for the magnitudes <strong>while </strong>they are being computed, so we must synchronize this.</p></li>
<li><p><strong>Edit 15/01/12</strong>: I committed a few changes on the lines above that brought some performance tweaks. It looks like the mutex isn&rsquo;t that necessary, and I also removed some dynamic memory allocations to save some CPU cycles.</p></li>
</ul>


<h3>Synchronize Audio Unit&rsquo;s data with UI</h3>

<p>So&hellip; how can we draw the spectrum graph once magnitudes have been computed by our <em>SimpleSpectrumProcessor</em> class? We have two options:</p>

<ul>
<li><p>We could add a <strong>NSTimer </strong>in the class <strong>SimpleSpectrum_UIView </strong>that cyclically &ldquo;asks&rdquo; for the computed magnitudes.</p></li>
<li><p>We could &ldquo;notify&rdquo; the class <strong>SimpleSpectrum_UIView </strong>each time new magnitudes have been computed.</p></li>
</ul>


<p>I tried both solutions, and I prefer the second one. To achieve this, you need to create a callback listener in the class <strong>SimpleSpectrum_UIView</strong>, and follow these guidelines:</p>

<ul>
<li><p>create the method <strong>dispatchAudioUnitEventProc </strong>with a special signature and register it as a callback method (SimpleSpectrum_UIView.mm, line 188)</p></li>
<li><p>register an <strong>AudioUnitEvent</strong> for every parameter/property you&rsquo;ve created (SimpleSpectrum_UIView.mm, lines 194-215)</p></li>
<li><p>catch a &ldquo;property changed&rdquo;  event for our custom properties <strong>kAudioUnitProperty_SpectrumGraphData</strong> and <strong>kAudioUnitProperty_SpectrumGraphInfo</strong>(SimpleSpectrum_UIView.mm, lines 144-149)</p></li>
<li><p>send this &ldquo;property changed&rdquo; event in the audio unit main code (SimpleSpectrum.cpp, line 89)</p></li>
<li><p>write a method that will pass properties to the UI (SimpleSpectrum.cpp, lines 95-150)</p></li>
<li><p>write a method that will draw magnitudes, or at least delegate this draw to the class <strong>SimpleSpectrum_GraphView</strong> (SimpleSpectrum_UIView.mm, lines 224-251)</p></li>
</ul>


<p>Okay, I admit that there is a lot of steps. There are many lines of code involved in this synchronization, written with different semantics, three programming languages, etc. Things could be easier, that&rsquo;s we&rsquo;ll perhaps discover when we&rsquo;ll write our first VST in an upcoming tutorial ;)</p>

<p>Though, our spectrum is still not moving. We need to talk about the class <strong>SimpleSpectrum_GraphView</strong> and its drawing techniques.</p>

<h3>Bringing the spectrum alive</h3>

<p>There are three things I would like to write about in this class.</p>

<p>First of all, the object <strong>NSBezierPath </strong>is my easy method for drawing the spectrum. All I have to do is moving to a certain <strong>NSPoint,</strong> then draw lines/curves using the methods <em>lineToPoint</em> and <em>curveToPoint</em> (or may I write &ldquo;messages&rdquo;? Since we are writing Objective-C&hellip;). There is a good tutorial on this <a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html">in the Apple documentation</a>.</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/bezier_curvec1.png"></p>

<p>Secondly, I use the object <strong>NSAffineTransform</strong> each time I need to change my coordinate system. This is important to understand that we have to draw several different things:</p>

<ul>
<li><p>the grid, from left-to-right and top-to-bottom</p></li>
<li><p>the frequencies/decibels labels, by transforming twice the coordinate system</p></li>
<li><p>the spectrum curve from left-to-right</p></li>
</ul>


<p>So either you get an headache with maths, either you feel sick using <strong>NSAffineTransform</strong>. I personally got an headache and felt sick, but the use of <strong>NSAffineTransform</strong> has structured my code. You should look at <a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaDrawingGuide/Transforms/Transforms.html#//apple_ref/doc/uid/TP40003290-CH204-BCIFCIHJ">this tutorial</a> for further explanations.</p>

<p>At last, you might notice a few additional things:</p>

<ul>
<li><p>that we have used a bunch of methods so as to draw frequencies/decibels in a logarithmic scale (SimpleSpectrum_GraphView.mm, lines 87-145)</p></li>
<li><p>that we have added some mouse callbacks in order to display the precise frequency/decibel under the mouse cursor (SimpleSpectrum_GraphView.mm, lines 334-374)</p></li>
</ul>


<p>We now have everything we need to build a clean Cocoa UI, and at this time, I hope that you have everything set up in your XCode environment and that you can hit &ldquo;Build&rdquo; to get your first debug release.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a FFT Analyzer Part II: Designing Our Spectral Processor]]></title>
    <link href="http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-ii-designing-our-spectral-processor/"/>
    <updated>2011-11-23T16:26:47+01:00</updated>
    <id>http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-ii-designing-our-spectral-processor</id>
    <content type="html"><![CDATA[<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/libs.jpeg"> We briefly introduced the FFT part of the Accelerated Framework in Part I of this tutorial.</p>

<p>We are now going to focus on the vDSP library and create the C++ class responsible for doing the spectral analysis work of our input samples. We want to keep it simple, with a few public methods, however we would like to perform FFT analysis on different frame sizes. So, one of our challenges is to design a circular buffer as member variable, which is a common pattern in audio programming.</p>

<!-- more -->


<h3>Xcode Setup</h3>

<p>In case you don&rsquo;t have your development environment initialized with a clean template for building audio units, I suggest you <a href="http://github.com/fredguile/SimpleSpectrumAnalyzer">download the source code of this tutorial</a>, then open the C++ class called <em>SimpleSpectrumProcessor.h</em> located in the &ldquo;Sources/SpectrumAU&rdquo; folder.</p>

<p>First of all, if you look at the &ldquo;PublicUtility&rdquo; folder of the CoreAudio SDK, you may notice a quite similar class called &ldquo;CASpectralProcessor&rdquo;. Actually, you can consider our class as a reduced version of &ldquo;CASpectralProcessor&rdquo;, more readable to my opinion, with a different buffers organization that allows the use of various FFT sizes upon time (between 1024 and 16384 frames). As common design, we will reuse the classes <em>CAAutoFree</em> and <em>CAAutoArrayDelete</em> so as to implement each data buffer. The former is basically an alternative to the std::auto smart pointer with the same restrictions on pointer ownership, but since it&rsquo;s using <em>malloc</em> to allocate memory, it will guarantee that the allocated memory is aligned on a 16-bits boundary (what vecLib needs). The latter is a similar version using &ldquo;new&rdquo; for memory allocation.</p>

<p>So you need to include the header &ldquo;PublicUtility/CAAutoDisposer.h&rdquo;, either in our class header, either in the project&rsquo;s precompiled headers section. You also need &lt;Accelerate/Accelerate.h> for the vDSP library and the &ldquo;vecLib.framework&rdquo; binary added to your build settings.</p>

<figure class='code'><figcaption><span>SimpleSpectrumProcessor.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">SimpleSpectrumProcessor</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'><span class="k">enum</span> <span class="n">Window</span> <span class="p">{</span> <span class="n">Rectangular</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Hann</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Hamming</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Blackman</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'><span class="n">UInt32</span> <span class="n">mNumChannels</span><span class="p">;</span>
</span><span class='line'><span class="n">UInt32</span> <span class="n">mRingBufferCapacity</span><span class="p">;</span>
</span><span class='line'><span class="n">UInt32</span> <span class="n">mRingBufferPosRead</span><span class="p">;</span>
</span><span class='line'><span class="n">UInt32</span> <span class="n">mRingBufferPosWrite</span><span class="p">;</span>
</span><span class='line'><span class="n">UInt32</span> <span class="n">mRingBufferCount</span><span class="p">;</span>
</span><span class='line'><span class="n">UInt32</span> <span class="n">mFFTSize</span><span class="p">;</span>
</span><span class='line'><span class="n">FFTSetup</span> <span class="n">mFFTSetup</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">mFFTSetupCreated</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">ChannelBuffers</span> <span class="p">{</span>
</span><span class='line'><span class="n">CAAutoFree</span><span class="o">&lt;</span><span class="n">Float32</span><span class="o">&gt;</span> <span class="n">mRingBufferData</span><span class="p">;</span>
</span><span class='line'><span class="n">CAAutoFree</span><span class="o">&lt;</span><span class="n">Float32</span><span class="o">&gt;</span> <span class="n">mInputData</span><span class="p">;</span>
</span><span class='line'><span class="n">CAAutoFree</span><span class="o">&lt;</span><span class="n">Float32</span><span class="o">&gt;</span> <span class="n">mSplitData</span><span class="p">;</span>
</span><span class='line'><span class="n">CAAutoFree</span><span class="o">&lt;</span><span class="n">Float32</span><span class="o">&gt;</span> <span class="n">mOutputData</span><span class="p">;</span>
</span><span class='line'><span class="n">CAAutoFree</span><span class="o">&lt;</span><span class="n">DSPSplitComplex</span><span class="o">&gt;</span> <span class="n">mDSPSplitComplex</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">CAAutoArrayDelete</span><span class="o">&lt;</span><span class="n">ChannelBuffers</span><span class="o">&gt;</span> <span class="n">mChannels</span><span class="p">;</span>
</span><span class='line'><span class="n">CAAutoFree</span><span class="o">&lt;</span><span class="n">Float32</span><span class="o">&gt;</span> <span class="n">mWindowData</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">protected</span><span class="o">:</span>
</span><span class='line'><span class="kt">void</span> <span class="n">InitFFT</span><span class="p">(</span><span class="n">UInt32</span> <span class="n">FFTSize</span><span class="p">,</span> <span class="n">UInt32</span> <span class="n">log2FFTSize</span><span class="p">,</span> <span class="n">UInt32</span> <span class="n">bins</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">ExtractRingBufferToFFTInput</span><span class="p">(</span><span class="n">UInt32</span> <span class="n">inNumFrames</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">ApplyWindow</span><span class="p">(</span><span class="n">Window</span> <span class="n">w</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'><span class="n">SimpleSpectrumProcessor</span><span class="p">();</span>
</span><span class='line'><span class="k">virtual</span> <span class="o">~</span><span class="n">SimpleSpectrumProcessor</span><span class="p">();</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">Allocate</span><span class="p">(</span><span class="n">UInt32</span> <span class="n">inNumChannels</span><span class="p">,</span> <span class="n">UInt32</span> <span class="n">ringBufferCapacity</span><span class="p">);</span>
</span><span class='line'><span class="kt">bool</span> <span class="nf">CopyInputToRingBuffer</span><span class="p">(</span><span class="n">UInt32</span> <span class="n">inNumFrames</span><span class="p">,</span> <span class="n">AudioBufferList</span><span class="o">*</span> <span class="n">inInput</span><span class="p">);</span>
</span><span class='line'><span class="kt">bool</span> <span class="nf">TryFFT</span><span class="p">(</span><span class="n">UInt32</span> <span class="n">inFFTSize</span><span class="p">,</span> <span class="n">Window</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Rectangular</span><span class="p">);</span>
</span><span class='line'><span class="n">CAAutoFree</span><span class="o">&lt;</span><span class="n">Float32</span><span class="o">&gt;</span> <span class="n">GetMagnitudes</span><span class="p">(</span><span class="n">Window</span> <span class="n">w</span><span class="p">,</span> <span class="n">UInt32</span> <span class="n">channelSelect</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>The first member variables are storing our circular buffer&rsquo;s capacity, fill count and two locations for reading/writing. Next, FFTSetup is holding the FFT weights array required by vDSP to perform the FFT transform. Concerning the buffers:</p>

<ul>
<li><p><em>mChannels</em> is an array containing various auto-pointers for each buffer we need : input/output data, split buffer to hold complex numbers that we&rsquo;ll access using our specific pointer <em>mDSPSplitComplex </em>(we&rsquo;ll explain that in a few seconds),</p></li>
<li><p><em>mWindowData </em>holds floating-pont numbers of the window function we&rsquo;ll choose to limit frequency leakage on our frequency spectrum (see <a href="http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-i-prerequisites-concerns-and-setup/">part I</a>),</p></li>
<li><p><em>mFFTSize </em>holds the FFT size, and we propose 5 values : 1024, 2048, 4096, 8192 or 16384 samples.</p></li>
</ul>


<p>By using auto-pointers as member variables (instead of simple pointers),  we use the RAII (&ldquo;resource acquisition is initialization&rdquo;) technique of C++ to free our buffers when our Audio Unit is released (or, of course, if an exception occur). That is to say, destructors for <em>CAAutoFree </em>and <em>CAAutoArrayDelete</em> will be called automatically when our main class is released.</p>

<p>Here is the basic workflow of this class:</p>

<ul>
<li><p>We first call <em>Allocate()</em> to initialize the circular buffer with a capacity of 16384 samples,</p></li>
<li><p> Each time our plugin render, we copy N frames to our circular buffer using <em>CopyInputToRingBuffer()</em>, then we call <em>TryFFT()</em> to compute those data,</p></li>
<li><p>In case the method <em>TryFFT()</em> returns successfully, we call <em>GetMagnitudes() </em>to obtain a floating-point array of magnitudes to display on a graph. We can get magnitudes for left/right channel separately (<em>channelSelect </em>is 1 or 2), or we can look at the average magnitudes of a stereo channel (<em>channelSelect </em>is 3).</p></li>
</ul>


<h3>Using a Ring Buffer</h3>

<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/200px-circular_buffer-svg.png?w=150"> Audio Units generally capture N input samples each time they are rendered, N being set by the host in which they operate. N has a value usually lower than the minimum number of  frames required for computing FFT, so before we can provide at least 1024 samples to FFT, we have those N samples stored into a ring buffer over a few cycles.</p>

<p> This kind of buffer is circular: thus, it never overflows. We always keep K samples in the ring buffer, K being the buffer&rsquo;s capacity. That&rsquo;s why we maintain two<em> int pointers</em> :</p>

<ul>
<li><p><em>mRingBufferPosRead</em> indicates where we must read when we extract samples to compute FFT,</p></li>
<li><p><em>mRingBufferPosWrite </em> is the same for writing into the ring buffer.</p></li>
</ul>


<p>We use an &ldquo;overlap-add&rdquo; algorithm to fill our ring buffer, that is, we possibly split the N samples being added, on part being stored at the end of the buffer and the other being stored from the beginning index. You can look at the method <em>CopyInputToRingBuffer</em> to get an example of such algorithm.</p>

<p>We also use this technique to extract N samples from the ring buffer (look at the protected method <em>ExtractRingBufferToFFTInput() </em> method). However, we ensure that enough samples have been stored into the buffer before we call this method.</p>

<p>You may note that our implement isn&rsquo;t thread-safe, hence all calls to the <em>SimpleSpectrunProcessor</em>&rsquo;s methods must be called from the same thread.</p>

<h3>Data packing for vDSP FFT</h3>

<p>The library vDSP.h provides two structures for packing the N samples you pass to the FFT: <em>DSPComplex </em>and <em>DSPSplitComplex</em>. You should first read the <a href="http://developer.apple.com/library/ios/#documentation/Performance/Conceptual/vDSP_Programming_Guide/UsingFourierTransforms/UsingFourierTransforms.html">neat article made by Apple on data packing</a>. Here is a summary:</p>

<ol>
<li><p>Your N samples are first stored into a 16-bits aligned float-point array, called our <em>input buffer</em>,</p></li>
<li><p>Whereas a real FFT would produce 2N complex numbers, the vDSP FFT truncates the result to store N/2 complex numbers in our <em>output buffer:</em> hence the input/output buffers have the same N size,</p></li>
<li><p>Prior to the FFT function, you need to reorganize your <em>input buffer</em> by copying your N samples into a <em>split buffer</em>.</p></li>
</ol>


<p>This <em>split buffer</em> is first initialized as a 16-bits aligned floating-point array, as you may read in the protected method <em>InitFFT()</em>. It is next accessed using a <em>DSPSplitComplex </em>structure that &ldquo;groups&rdquo; floating-point together, for this buffer to behave as an array of N/2 complex numbers (with both real and imaginary parts).</p>

<p><em><em>This is important to remember that the last mandatory step before we can compute FFT is to reorganize you </em>split buffer</em> by calling <strong>vDSP_ctoz</strong>: this will &ldquo;pack&rdquo; floating-point numbers for the vDSP FFT by a stride of 2.</p>

<p>For instance,  if your input buffer is [x1, x2, x3, x4, x5, x6, x7, x8], then your split buffer will be [x1, x5, x2, x6, x3, x7, x4, x8]. After FFT, you&rsquo;ll get [c1.real, c1.imag, c2.real, c2.imag, c3.real, c3.imag, c4.real, c4.imag]. But, if the <em>DSPSplitComplex</em> structure can see interleaved complex numbers like previously, our split buffer remains an aligned buffer with [c1.real, c2.real, c3.real, c1.imag, c2.imag, c3.imag, c4.imag].</p>

<h3>The power of SIMD</h3>

<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/images-1.jpeg?w=150"> What is the plot of having all those buffers ? We could have reworked things to diminish memory footprint.</p>

<p>Instead, we&rsquo;ll use the great SIMD features of the vDSP library with no proprietary code at all!  The benefit here is to drastically reduce the computing time of a large number of samples. Furthermore, vDSP provide numerous mathematical functions that will help us achieve our sound analysis.</p>

<p>At first sight, there are a lot of functions. You&rsquo;ll soon get use to the naming conventions used by Apple to find the good one: for instance, if you are looking to a vector-scalar operation, you may search for a function named vDSP_vs[something] or vDSP_sv[something]. It you are working with 64-bits IEEE floating point numbers, you will look at the functions named vDSP_[something]D (D for double).</p>

<p>Here is what our SimpleSpectrumAnalyzer will do:</p>

<ol>
<li><p>First, we determine our current windowing function by simply calling one of the ready-to-use functions: <strong>vDSP_hann_window </strong>(Hann), <strong>vDSP_hamm_window</strong> (Hamming) or <strong>vDSP_blkman_window</strong> (Blackman)</p></li>
<li><p>We multiply our N samples with the window function using <strong>vDSP_vmul</strong></p></li>
<li><p>As seen above, our DSPComplexSplit structure is organized by <strong>vDSP_ctoz</strong></p></li>
<li><p>We compute FFT with <strong>vDSP_fft_zip </strong>(as a naming convention, &ldquo;z&rdquo; stands for complex numbers),</p></li>
<li><p>Magnitude of a complex number can be obtained with <strong>vDSP_zvabs </strong>(we could have possibly used <strong>vDSP_zvmags</strong>, see below)</p></li>
<li><p>We next normalize our magnitudes, by dividing then by two, using <strong>vDSP_vsdiv </strong>(since we got N/2 complex numbers which is half of the N input samples)</p></li>
<li><p>We convert magnitudes to a decibel value using <strong>vDSP_vdbconv</strong></p></li>
<li><p>We correct each decibel values by applying a Db correction with <strong>vDSP_vadd</strong></p></li>
<li><p>We could possible obtain an average value for left and right channels using <strong>vDSP_vadd</strong> and <strong>vDSP_vsdiv</strong>.</p></li>
</ol>


<p>We&rsquo;ll leave these steps unchanged to keep this tutorial simple, though we could have tweaked things a bit. As you know, the decibel formula is given by:</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/062fdd96385ff2ddfdb4426194c49b29.png"></p>

<p>As an optimization, rather than multiplying/dividing U1 or U2, we could have left U1 unchanged, called <strong>vDSP_vdbconv</strong>, then take this into account when applying our dB correction. Indeed, every multiplication or division on U1 can translate into an addition or deletion on log10(U1). In the same manner, we could have used <strong>vDSP_zvmags</strong> instead of <strong>vDSP_zvabs</strong> and saved one <em>sqrt </em>operation.</p>

<h3>Using SimpleSpectrumProcessor in our Audio Unit</h3>

<p>We&rsquo;ll wrap up this part by showing you how our SimpleSpectrumProcessor is used in the main code. Basically:</p>

<ul>
<li><p>It&rsquo;s a member variable of the main class <em>SimpleSpectrum.h</em> (hence all of our resources are released using the RAII technique),</p></li>
<li><p>We override the <em>AUEffectBase::Render()</em> method, responsible for grabbing N samples from the audio inputs and computing FFT,</p></li>
<li><p>You may notice that we aren&rsquo;t using the class <em>SimpleSpectrumKernel</em> at all, even if we have overridden the method <em>AUKernelBase::Process()</em>, which is a required step for our Audio Unit to be validated by the <strong>auval</strong> tool.</p></li>
</ul>


<p>Here the snippet of the main work:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">AudioBufferList</span><span class="o">&amp;</span> <span class="n">inputBufList</span> <span class="o">=</span> <span class="n">GetInput</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetBufferList</span><span class="p">();</span>
</span><span class='line'><span class="n">mProcessor</span><span class="p">.</span><span class="n">CopyInputToRingBuffer</span><span class="p">(</span><span class="n">inFramesToProcess</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inputBufList</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">mProcessor</span><span class="p">.</span><span class="n">TryFFT</span><span class="p">(</span><span class="n">currentBlockSize</span><span class="p">,</span> <span class="n">currentWindow</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">CAAutoFree</span><span class="o">&lt;</span><span class="n">Float32</span><span class="o">&gt;</span> <span class="n">magnitudes</span> <span class="o">=</span> <span class="n">mProcessor</span><span class="p">.</span><span class="n">GetMagnitudes</span><span class="p">(</span><span class="n">currentWindow</span><span class="p">,</span> <span class="n">channelSelect</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Conclusion</h3>

<p>I let you examine the Apple documentation to get acquainted of the different methods you can override from the base classes <em>AUEffectBase </em>and <em>AUBase</em>. In an upcoming tutorial, we will make a better use of the <em>AUKernelBase</em> class, but in the meantime, we shall look how we&rsquo;ll build a GUI to draw our spectrum data.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a FFT Analyzer Part I: Prerequisites, Concerns and Setup]]></title>
    <link href="http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-i-prerequisites-concerns-and-setup/"/>
    <updated>2011-11-23T16:17:44+01:00</updated>
    <id>http://sample-hold.github.io/2011/11/23/create-a-fft-analyzer-part-i-prerequisites-concerns-and-setup</id>
    <content type="html"><![CDATA[<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/capture-d_c3a9cran-2011-11-29-c3a0-13-31-29.png"> It&rsquo;s time to build up our first audio unit.</p>

<p>For a start, I propose to create a spectrum analyzer which will help us to understand how we can realize basic sound analysis using the Fourier Transform. While this might sound scarily complex for non mathematician developers, you will smoothly read this tutorial if we first explain a few concepts about sound processing, without of course entering too deeply into the maths&hellip;</p>

<!-- more -->


<h3>About the Fourier transform</h3>

<p>Well, in fact, we shall talk a bit about maths.</p>

<p>As you might not know, the Fourier transform is a powerful mathematical tool that can translate an audio signal, represented by a function x(t)  in the time domain, into another function X(α) in the frequency domain (α having its unit in radiant). This is exactly what we need in order to analyze every frequency that compose the audio signal coming through each input of our Audio Unit.</p>

<p>To understand how this computation works, I may suggest you reading <a href="http://www.dspdimension.com/admin/dft-a-pied/">this great tutorial from Stephan Bernsee</a>. He explains how Joseph Fourier, back in the nineteenth century, found out that a periodic signal could be decomposed into a sum of simpler periodic functions which are our well known functions <strong>sinus</strong> and <strong>cosinus</strong> .</p>

<p>I personally had no difficulty to read Stephan&rsquo;s tutorial, yet I couldn&rsquo;t figure out what was the relationship between sinuses and cosinuses once we were in the frequency domain. The answer, unfortunately, is tied to a dull mathematical concept : <strong>complex numbers</strong>. That is, if our audio signal can be represented with a bunch of real numbers, the resulting function X(α) uses complex numbers to represent frequencies that compose our signal, simply because the Fourier transform uses the exponential function (also known as the<strong> Euler formula</strong>), which translates real numbers from the Real domain (as input) to complex numbers into the Complex plane (as output).</p>

<p>Well, it is almost  time for me to close this book and go to bed, except perhaps if you tell me a &ldquo;concrete&rdquo; method for visualizing F(α). That&rsquo;s where we use our Wikipedia card to steal a graphical representation of the Euler formula :</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/220px-eulers_formula.png"></p>

<p>Look at this unit circle drawn in the complex plane carefully, and I promise that an explanation will shade out in a couple of seconds.</p>

<p>Just imagine that the Fourier transform F(α) draws some plots inside the above circle, thus you can draw those evil complex numbers on the complex plane with each coordinate being <strong>x = Real part = cos α and y = Imaginary part = sin α</strong>. Put your finger at the rightmost plot on this circle, where α = 0, then start moving on the circle in the counterclockwise direction. For every α frequency between 0 and 2π, you can determine at least two properties, the phase and magnitude, by using simple trigonometry with the corresponding complex number on F(α).</p>

<p>Since our concern for building our spectrum analyzer is to only get the magnitude, I&rsquo;ll ignore phase for this tutorial. To compute the magnitude, you just may remember the famous Pythagorean theorem which says&hellip; well, do you remember ?</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/162px-pythagorean_theorem_abc-svg2.png"></p>

<p>That is, (magnitude(α))² = Real part² + Imaginary part² = (cos α)² + (sin α)², hence magnitude(α) = SQRT(Real part² + Imaginary part²) = SQRT((cos α)² + (sin α)²). We have almost everything we need, though some last details will be be discussed at a later stage of this tutorial.</p>

<p>So far, to wrap things up, we need to :</p>

<ul>
<li><p>compute the Fourier transform F(α) of our audio signal f(t)</p></li>
<li><p>for each frequency α, compute it&rsquo;s magnitude</p></li>
<li><p>then, draw a beautiful spectrum analysis</p></li>
</ul>


<p>Fortunately, we do not have to compute the Fourier Transform by hand (that&rsquo;s why I&rsquo;m not giving you the formula). A lot of optimized algorithms are available,  and among those, there is the "<strong>Fast Fourier Transform</strong>&ldquo; (FFT), which is able to compute the Fourier transform very quickly, given a windowed audio signal of N samples, N being a power of two.</p>

<p>The last statement isn&rsquo;t exactly true : in fact, the FFT is an algorithm for the &ldquo;Discrete-Time Fourier Transform&rdquo; (DTFT), which is a specific FT applied to a discrete time function x(n) representing our<strong> sampled audio signal</strong> received by our Audio Unit. There aren&rsquo;t many differences, apart the fact that since we provide to the FFT a window of N samples, the DTFT is an approximation of the FT that necessarily introduce precision loss in our spectrum analysis. This is called the &ldquo;uncertainty principle&rdquo;.</p>

<p>By the way, I think we cool look at the DTFT formula to learn a few things about the FFT :</p>

<p><img class="centered" src="http://sample-hold.github.io/images/blog/dtft.png"></p>

<p>What I can read here is that we&rsquo;ll pass N samples (N being a power of 2, as said above) to the FFT transform, in order to get at most N complex numbers describing frequencies on the complex plane (we&rsquo;ll choose the value for N later in the tutorial). So, as a developer, you will have to extract those N samples, store them in a buffer, and prepare an array of dimension to 2N to receive the resulting complex numbers.</p>

<p>Those resulting complex numbers can be split into two equal parts : the complex part and its conjugate. Since all the conjugates aren&rsquo;t necessary for our audio analysis, you will see that we&rsquo;ll be using a library that truncates them and store in fact N/2 complex numbers in a buffer equal to an array of dimension N.  We use to call those N/2 complex number our &ldquo;bins&rdquo; (like in Bernsee&rsquo;s tutorial), and these &ldquo;bins&rdquo; gives us magnitude for N/2 frequencies. Thus, it&rsquo;s important to choose a relevant size for N so as to not introduce too much precision loss in our spectrum analysis.</p>

<p>Are we done? Nope, there is one last pitfall that our spectrum analysis must handle : frequency leakage.</p>

<h3>Frequency leakage</h3>

<p>I suggest reading <a href="http://zone.ni.com/devzone/cda/tut/p/id/4844">this tutorial</a> to understand frequency leakage. What can we say about it ? Well, we cannot completely eliminate this phenomenon, but we can limit it by applying a window function to our N samples before we pass them to the FFT.</p>

<p>There are several window function available, but I&rsquo;ll choose only three to include to this tutorial, so as to illustrate frequency leakage : Hann, Hamming and Blackman.</p>

<p>So finally, here are the steps that we need develop in our Audio Unit :</p>

<ul>
<li><p>extract N samples of our audio signal</p></li>
<li><p>apply a window function to our N samples</p></li>
<li><p>compute the FFT</p></li>
<li><p>for each &ldquo;bin&rdquo;  that correspond to an approximation of a frequency, compute it&rsquo;s magnitude</p></li>
<li><p>at last, draw an almost perfect FFT analysis</p></li>
</ul>


<p>For the good news, I announce that my mathematical thoughts are (almost) over, and that we may now introduce the killer library that will help us achieve those beautiful things.</p>

<h3>When comes the Accelerate framework</h3>

<p>The Accelerate framework is part of Mac OS X since version 10, and honestly it&rsquo;s a gift given to developers that would like to do computational programs in an efficient way. Part of it, the <strong>vecLib</strong> library provides the FFT transform and many other mathematical functions, whose fast algorithms use vector processing units of x86 (and formerly PowerPC) processors. That is to say, vecLib use SIMD units (&ldquo;single instruction multiple data&rdquo;) of your processor(s), like Intel x86 SSE extensions, to accelerate FTT computing.</p>

<p>Because we&rsquo;ll be using <strong>vecLib</strong> in our tutorial, there are two concerns we have to keep in mind :</p>

<ul>
<li><p>we need to design our buffers used for FFT computation so that their memory is aligned on a 16-bits boundary,</p></li>
<li><p>we may preferably allocate our buffers memory in contiguous spaces, thus avoiding paging operations between two SIMD instructions (that would cut down performances and cancel benefit provided by the SIMD units).</p></li>
</ul>


<p>Don&rsquo;t worry, we won&rsquo;t implement any hard programmatic scheme to solve this : we&rsquo;ll just revisit those two requirements when we&rsquo;ll be designing our simple class called <em>SimpleSpectrumProcessor  </em>that handled all the FFT processing in part II of this tutorial.</p>

<h3>Which GUI ?</h3>

<p>This is not the most efficient choice for Audio Units, but for studying purpose, we&rsquo;ll design our UI using Cocoa and Objective-C. That way, we&rsquo;ll see in part III of the tutorial how to mix two different languages in the same XCode project.</p>

<h3>The Setup</h3>

<p>We&rsquo;ll start with the XCode template we had previously created in <a href="http://guileboard.wordpress.com/2011/11/23/gettin-started-with-audio-units-on-os-x-lion-and-xcode-4-2-1/">my first article</a>. While our main sources will be written in C++, we&rsquo;ll create a second folder to store our Objective-C code, and also add an additional target to build the Cocoa UI.</p>

<p>There are a few last steps you may require before you can move to the next part of the tutorial. I leave them as an exercise for the reader :</p>

<ol>
<li><p>Create a new XCode projet called &ldquo;SimpleSpectrumAnalyzer&rdquo; that can build an Audio Effect for OS X Lion</p></li>
<li><p>Add the &ldquo;vecLib.framework&rdquo; and the &ldquo;Cocoa.framework&rdquo; to your project</p></li>
<li><p> Create two deployment targets:</p></li>
<li><p> one to build the Audio Unit file &ldquo;SimpleSpectrumAnalyzer.component&rdquo;,</p></li>
<li><p>another one to build  the second bundle called &ldquo;SpectrumCocaView.bundle&rdquo;, which will contain the CocoaUI</p></li>
<li><p>Find a way, by tweaking the build phases, to include the second bundle as a resource into the first bundle</p></li>
</ol>


<p>Once done, we are ready to gather all the concepts seen in this article in a simple C++ class, <em>SimpleSpectrumProcessor</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With Audio Units on OS X Lion and XCode 4.2.1]]></title>
    <link href="http://sample-hold.github.io/2011/11/23/getting-started-with-audio-units-on-os-x-lion-and-xcode-4-2-1/"/>
    <updated>2011-11-23T15:59:23+01:00</updated>
    <id>http://sample-hold.github.io/2011/11/23/getting-started-with-audio-units-on-os-x-lion-and-xcode-4-2-1</id>
    <content type="html"><![CDATA[<p><img class="alignleft" src="http://sample-hold.github.io/images/blog/home-ios-sdk.png"> Apple usually takes care of their developers community.  Whereas they lately delivered an impressive update of their Xcode IDE with tons of new features (read a <a href="http://pilky.me/view/28">cool  review here</a>), they surprisingly removed the project template for creating Audio Units. Nevertheless, let&rsquo;s see how to create a new unit from scratch&hellip;</p>

<!-- more -->


<p>Of course, the Core Audio SDK is still located in /Developer/Extras/CoreAudio and it&rsquo;s still possible to develop Audio Units with XCode 4.2. So you have two solutions :</p>

<ul>
<li><p>either you grab a sample code from Apple documentation (like &ldquo;FilterDemo&rdquo; for instance) and migrate it to suit the latest changes done in OS X Lion for the Core Audio SDK (there is an <a href="http://developer.apple.com/library/mac/#technotes/tn2276/_index.html#//apple_ref/doc/uid/DTS40011031">official technical note to read here</a>),</p></li>
<li><p>or you can learn, by following this tutorial, how to build you audio unit template from scratch in only a few steps !</p></li>
</ul>


<p><strong>EDIT for XCode 4.3.2 users: You may have noticed that starting from version 4.3.2, XCode is now a bundled app installed in /Applications. There is no more /Developer folder and since you are likely to use the CoreAudio API, you absolutely need to dowload the optional package named &ldquo;Audio Tools for XCode&rdquo; from the Apple website. Please click on XCode > Open Developer Tool > More Developer Tools&hellip; to reach the dowload page. And of course, you&rsquo;ll have to rewrite by yourself some links provided in this tutorial.</strong></p>

<h3>Create the project</h3>

<p>You need to create a new project using the template &ldquo;Mac OS X > Framework &amp; Library >Bundle&rdquo;.</p>

<p>Indeed, an Audio Unit is basically a bundle with a different file name extension &ldquo;.component&rdquo;. When asked, select &ldquo;Cocoa&rdquo; as framework, even if none of the proposed choices suit our needs for now. We&rsquo;ll clean those unwanted libraries later.</p>

<h3>Organize your files</h3>

<p>Your project must contain at least :</p>

<ul>
<li><p>one group for storing all C++ sources files, including your created classes and some sources coming from the CoreAudio SDK you will necessarily use,</p></li>
<li><p>one group for storing your resources, including a &ldquo;property list&rdquo; manifest  that describes your audio unit,</p></li>
<li><p>possibly one additional folder for C++ - or Objective-C sources - to create a GUI for your unit. However, for sake of simplicity, we&rsquo;ll discuss this in another tutorial. Leave it for now.</p></li>
</ul>


<p>By the way, don&rsquo;t neglect the &ldquo;Identity&rdquo; pane displayed when you open the rightmost view. You&rsquo;ll find two fields, &ldquo;Location&rdquo; and &ldquo;Full Path&rdquo; that can help you cleaning the mess if you want to add / delete a lot of files, or create new groups that &ldquo;map&rdquo; to existing folders in your project directory.</p>

<h3><img class="centered" src="http://sample-hold.github.io/images/blog/identity.png"></h3>

<h3>Tune your deployment target</h3>

<p>Click on the project&rsquo;s name to display the available deployment targets.</p>

<p>You can reuse the default target created by Xcode. The first tab &ldquo;Info&rdquo; shows the content of the property list file located in your resources folder (if not, check the path entered in the tab &ldquo;build settings&rdquo;, under the key &ldquo;Info.plist File&rdquo;). There is only one piece of information missing here : you must add a new Dictionary called &ldquo;AudioComponent&rdquo; containing at least  7 strings :</p>

<ul>
<li><p><strong>manufacturer</strong>: your name</p></li>
<li><p><strong>factoryFunction</strong>: the classname of your factory, for this tutorial type &ldquo;MyTestedPluginFactory&rdquo;</p></li>
<li><p><strong>subtype</strong>: a 4-alphanumeric code categorizing your unit, for instance &ldquo;TEST&rdquo;</p></li>
<li><p><strong>description</strong>: a brief description</p></li>
<li><p><strong>type</strong>: a 4-alphanumeric code defining your unit type. Please consult SDK documentation to get all the available types : for this tutorial, we are creating an audio effect, so type &ldquo;aufx&rdquo;</p></li>
<li><p><strong>name</strong>: your plugin&rsquo;s name</p></li>
<li><p><strong>version</strong>: an hexadecimal number defining the version number of the unit. The magic here wants you to enter OxMMMMmmHH, where MMMM is major version, mm is minor version and HH is hotfix number. But if, like me, you want to test your updated plugin every time you compile a new version, just enter &ldquo;0xFFFFFFFF&rdquo;.</p></li>
</ul>


<p><img class="centered" src="http://sample-hold.github.io/images/blog/info.png"></p>

<p>Next, move ahead to the tab &ldquo;Build settings&rdquo;. Toggle the filter from &ldquo;Basic&rdquo; to &ldquo;All&rdquo; and proceed to a few changes on values :</p>

<ul>
<li><p>Architectures: I suggest creating a standard 32/64-bit Intel binary</p></li>
<li><p>Build active architecture only: choose &ldquo;no&rdquo;</p></li>
<li><p>Compiler for C/C++/Objective-C: this is not mandatory, but if you wish to use the new compiler LLVM 3.0, help yourself</p></li>
<li><p>Linking > Other linker flags: ensure &ldquo;-bundle&rdquo; is specified</p></li>
<li><p>Wrapper extension: change this extension and write &ldquo;component&rdquo;</p></li>
<li><p>Rez Search path: You need two values here</p>

<ul>
<li><p>/Developer/Extras/CoreAudio/AudioUnits/AUPublic/AUBase</p></li>
<li><p>/System/Library/Frameworks/CoreServices.framework/Frameworks/CarbonCore.framework/Versions/A/Headers</p></li>
</ul>
</li>
<li><p>Precompile prefix header: choose &ldquo;yes&rdquo;. I suggest using the one provided by the Xcode template.</p></li>
</ul>


<p>There will be one more key to adjust, but we can&rsquo;t see it until we have modified the &ldquo;Build phases&rdquo; first. So let&rsquo;s move to this third tab.</p>

<h3>Refactor the build phases</h3>

<p>Honestly, I find the XCode build system absolutely wonderful. Everything you need is to add a few build phases then XCode will compile and link your binary without asking too much questions.</p>

<p>Here are the build phases to add for our Audio Unit:</p>

<ol>
<li><p>Copy Bundle Resources: this may already exist. You will necessarily include in this phase the Info.PList we tweaked earlier.</p></li>
<li><p>Copy Headers: necessary to compile you C++ header files. We&rsquo;ll add files to this phase later.</p></li>
<li><p>Compile Sources: necessary to compile you C++ source code. Again, we&rsquo;ll add files to this phase later.</p></li>
<li><p>Link Binary with libraries: do your shopping but add at least three libraries : &ldquo;CoreServices.framework&rdquo;, &ldquo;AudioToolbox.framework&rdquo; and &ldquo;AudioUnit.framework&rdquo;. Remove everything else (even &ldquo;Cocoa&rdquo;).</p></li>
<li><p>Build Carbon Resources: it looks like you won&rsquo;t see this build phase until you create a file named &ldquo;MyTestedPlugin.r&rdquo; in your project (preferably in your &ldquo;Sources&rdquo;  group). Create it, then go back to your build phases, then you will be able to add this phase and include the file above.</p></li>
</ol>


<p>There are a few additional build phases we could discuss, but I reserve them for an upcoming tutorial.</p>

<p>Wait&hellip; you still need to go back to the &ldquo;Build settings&rdquo; tab and change the remaining key &ldquo;Other Rez Flag&rdquo;, by entering this:</p>

<pre><code>-d i386_$i386 -I /System/Library/Frameworks/CoreServices.framework/Frameworks/CarbonCore.framework/Versions/A/Headers -I /Developer/Extras/CoreAudio/AudioUnits/AUPublic/AUBase
</code></pre>

<p>Here we are.</p>

<h3>Fine-tune your precompiled header</h3>

<p>Here is the minimal precompiled header you would write for your Audio Unit :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)</span>
</span><span class='line'><span class="cp">#include &lt;CoreAudio/CoreAudioTypes.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;CoreFoundation/CoreFoundation.h&gt;</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'><span class="cp">#include &lt;CoreAudioTypes.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;CoreFoundation.h&gt;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &quot;AUEffectBase.h&quot;</span>
</span><span class='line'><span class="cp">#include &lt;AudioToolbox/AudioUnitUtilities.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Add CoreAudio files to your project</h3>

<p>Right-click on your &ldquo;Sources&rdquo; group and choose &ldquo;Add files to MyTestedPlugin&hellip;&rdquo;.</p>

<p>Move to /Developer/Extras/CoreAudio.</p>

<p>I&rsquo;ll give you a precious advice here: before you click on &ldquo;Add&rdquo;, ensure that &ldquo;Add to Targets: MyTestedPlugin&rdquo; and &ldquo;Create groups for any added folders&rdquo; are <strong>selected</strong>.</p>

<p>You will find below the list of the folders/files you absolutely need to add to your project :</p>

<ul>
<li><p>AudioUnits/AUPublic/AUBase</p></li>
<li><p>AudioUnits/AUPublic/OtherBases/AUEffectBase.*</p></li>
<li><p>AudioUnits/AUPublic/Utility</p></li>
<li><p>PublicUtility/CAVectorUnit.*</p></li>
<li><p>PublicUtility/CAAudioChannelLayout.*</p></li>
<li><p>PublicUtility/CAHostTimeBase.*</p></li>
<li><p>PublicUtility/CAStreamBasicDescription.*</p></li>
<li><p>PublicUtility/CADebugMacros.*</p></li>
<li><p>PublicUtility/CAException.*</p></li>
<li><p>PublicUtility/CAXException.*</p></li>
<li><p>PublicUtility/CAAutoDisposer.h</p></li>
<li><p>PublicUtility/CAMath.h</p></li>
<li><p>PublicUtility/CAThreadSafeList.*</p></li>
</ul>


<p>Normally, all the .h and .cpp files have been added automatically to the &ldquo;Copy headers&rdquo; and &ldquo;Compile sources&rdquo; build phases. If not, you&rsquo;ll have to add them manually by editing your build phases.</p>

<h3>It&rsquo;s time to code !</h3>

<p>You may create at least one header file and one cpp file for your custom classes. For the purpose of our tutorial, here are the minimalistic classes you need to copy'n'paste:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">MyTestedPluginKernel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AUKernelBase</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">MyTestedPluginKernel</span><span class="p">(</span><span class="n">AUEffectBase</span> <span class="o">*</span> <span class="n">inAudioUnit</span><span class="p">);</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Process</span><span class="p">(</span><span class="n">Float32</span> <span class="k">const</span><span class="o">*</span> <span class="n">inSourceP</span><span class="p">,</span>
</span><span class='line'>                         <span class="n">Float32</span> <span class="o">*</span> <span class="n">inDestP</span><span class="p">,</span>
</span><span class='line'>                         <span class="n">UInt32</span> <span class="n">inFramesToProcess</span><span class="p">,</span>
</span><span class='line'>                         <span class="n">UInt32</span> <span class="n">inNumChannels</span><span class="p">,</span>
</span><span class='line'>                         <span class="kt">bool</span> <span class="o">&amp;</span> <span class="n">ioSilence</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MyTestedPlugin</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AUEffectBase</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">MyTestedPlugin</span><span class="p">(</span><span class="n">AudioUnit</span> <span class="n">component</span><span class="p">);</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">OSStatus</span> <span class="nf">Version</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mh">0xFFFFFF</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">OSStatus</span> <span class="nf">Initialize</span><span class="p">();</span>
</span><span class='line'>  <span class="k">virtual</span> <span class="n">AUKernelBase</span> <span class="o">*</span> <span class="nf">NewKernel</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">MyTestedPluginKernel</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">AUDIOCOMPONENT_ENTRY</span><span class="p">(</span><span class="n">AUBaseFactory</span><span class="p">,</span> <span class="n">MyTestedPlugin</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">MyTestedPluginKernel</span><span class="o">::</span><span class="n">MyTestedPluginKernel</span><span class="p">(</span><span class="n">AUEffectBase</span> <span class="o">*</span> <span class="n">inAudioUnit</span> <span class="p">)</span> <span class="o">:</span> <span class="n">AUKernelBase</span><span class="p">(</span><span class="n">inAudioUnit</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">MyTestedPluginKernel</span><span class="o">::</span><span class="n">Process</span><span class="p">(</span><span class="n">Float32</span> <span class="k">const</span><span class="o">*</span> <span class="n">inSourceP</span><span class="p">,</span> <span class="n">Float32</span> <span class="o">*</span> <span class="n">inDestP</span><span class="p">,</span> <span class="n">UInt32</span> <span class="n">inFramesToProcess</span><span class="p">,</span> <span class="n">UInt32</span> <span class="n">inNumChannels</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">&amp;</span> <span class="n">ioSilence</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="c1">//This code will pass-thru the audio data.</span>
</span><span class='line'><span class="c1">//This is usually where you want to process data to produce an effect.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">MyTestedPlugin</span><span class="o">::</span><span class="n">MyTestedPlugin</span><span class="p">(</span><span class="n">AudioUnit</span> <span class="n">component</span><span class="p">)</span> <span class="o">:</span> <span class="n">AUEffectBase</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="n">OSStatus</span> <span class="n">MyTestedPlugin</span><span class="o">::</span><span class="n">Initialize</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'><span class="n">OSStatus</span> <span class="n">result</span> <span class="o">=</span> <span class="n">AUEffectBase</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">noErr</span> <span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="err"> </span>  <span class="c1">// do something</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>You ought to not omit the macro AUDIOCOMPONENT_ENTRY, since it&rsquo;s responsible for creating the stub classes MyTestedPluginEntry and MytestedPluginFactory as entry points for your Audio Unit.</p>

<h3>Populate Carbon resource file</h3>

<p>Remember the file &ldquo;MyTestedPlugin.r&rdquo; you created earlier ? It&rsquo;s time to fill it with standard content :</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;AudioUnit/AudioUnit.r&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define RES_ID    1000</span>
</span><span class='line'><span class="cp">#define COMP_TYPE &#39;aufx&#39;</span>
</span><span class='line'><span class="cp">#define COMP_SUBTYPE &#39;TEST&#39;</span>
</span><span class='line'><span class="cp">#define COMP_MANUF &#39;FRED&#39;</span>
</span><span class='line'><span class="cp">#define VERSION 0xFFFFFFFF</span>
</span><span class='line'><span class="cp">#define NAME &quot;Test Plugin&quot;</span>
</span><span class='line'><span class="cp">#define DESCRIPTION &quot;description&quot;</span>
</span><span class='line'><span class="cp">#define ENTRY_POINT &quot;MyTestedPluginEntry&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &quot;AUResources.r&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This step remains to keep backward compatibility with previous versions of CoreAudio SDK. You may  copy and past the information you wrote in the Info.PList.</p>

<p>I suggest to try compiling your project after you have finished this step. If you get any &ldquo;Rez error&rdquo;, you should check that in your build phase &ldquo;Build Carbon Resources&rdquo;, the file above is the <strong>only</strong> file added to the task.</p>

<h3>Export Symbols</h3>

<p>There is one last important step you need to do : you must configure the linker to indicate that two symbols, &ldquo;MyTestedPluginFactory&rdquo; and &ldquo;MyTestedPluginEntry&rdquo; , are available for use in your component.</p>

<p>Create a file MyTestedPluginEntry.exp that contains :</p>

<pre><code>_MyTestedPluginFactory
_MyTestedPluginEntry
</code></pre>

<p>Then go to your project build settings and give the path to this file into the key &ldquo;Exported Symbols File&rdquo;.</p>

<h3>Compile, test and go!</h3>

<p>You should be able to compile you Audio Unit  now, but before we go we have to test using <em>auval </em>:</p>

<ol>
<li><p>First, copy your compiled component into ~/Library/Audio/Plug-Ins/Components</p></li>
<li><p>Secondly, open Terminal and type :</p>

<p>auval -v aufx TEST FRED</p></li>
</ol>


<p>In case you&rsquo;ve made a 64 bits plugin, you should rather type :</p>

<pre><code>auval -64 -v aufx TEST FRED
</code></pre>

<p>Auval is processing a bunch of tests to validate your Audio Unit. Since it currently does nothing, you should get the PASS mention and see it in you favourite sequencer as an audio effect.</p>

<h3>Conclusion</h3>

<p>I agree that this tutorial isn&rsquo;t the funniest you&rsquo;ve ever read, but it was necessary to setup our template to move on more interesting things in our next tutorials. We&rsquo;ll soon see how we can make some fun out of this Xcode template.</p>

<p><a href="https://github.com/Sample-Hold/SimpleEmptyAudioEffect">Click here to download the sources for Xcode 4.2.1</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Greetings!]]></title>
    <link href="http://sample-hold.github.io/2011/11/21/greetings/"/>
    <updated>2011-11-21T15:46:12+01:00</updated>
    <id>http://sample-hold.github.io/2011/11/21/greetings</id>
    <content type="html"><![CDATA[<p>Whether you have been thrown out here by Google or came deliberately&hellip; welcome! I&rsquo;ll write a couple of audio tutorials in the next articles. The sole things you need are a OS X Lion and Xcode 4.2. Later, we may study other SDK/platforms like Steinberg VST and Windows. Have a nice reading !</p>
]]></content>
  </entry>
  
</feed>
